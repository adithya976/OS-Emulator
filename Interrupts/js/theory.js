// Theory content for each tab
const theoryContent = {
    intro: `
      <h3>Understanding CPU Interrupts</h3>
      <p>
        CPU interrupts are signals sent to the processor that temporarily halt the execution of the current program
        to handle some immediate need. They allow the operating system to respond to events that require immediate attention,
        such as input from a keyboard, a timer expiring, or a hardware error.
      </p>
      <p>
        The interrupt mechanism is fundamental to multitasking operating systems, allowing them to manage multiple processes and
        respond to external events efficiently without constantly checking for them (known as polling).
      </p>
      <p>
        Key components of interrupt handling include:
      </p>
      <ul>
        <li><strong>Interrupt Vector Table (IVT)</strong> - A data structure that maps interrupt types to their handlers</li>
        <li><strong>Interrupt Service Routines (ISRs)</strong> - Code that executes when an interrupt occurs</li>
        <li><strong>Process Control Block (PCB)</strong> - Stores process state when it's interrupted</li>
      </ul>
      <p>
        The interactive simulation on this page demonstrates how these components work together when
        an interrupt occurs in a real operating system.
      </p>
    `,
    
    interrupts: `
      <h3>Types of Interrupts</h3>
      <p>
        Interrupts can be classified into several categories:
      </p>
      <ol>
        <li>
          <strong>Hardware Interrupts</strong> - Generated by hardware devices:
          <ul>
            <li><em>Keyboard Interrupts</em> - Generated when a key is pressed</li>
            <li><em>Timer Interrupts</em> - Generated by the system timer at regular intervals</li>
            <li><em>I/O Interrupts</em> - Generated when an I/O operation completes</li>
            <li><em>Hardware Error Interrupts</em> - Generated when hardware failures occur</li>
          </ul>
        </li>
        <li>
          <strong>Software Interrupts</strong> - Generated by programs:
          <ul>
            <li><em>System Calls</em> - When a program requests an OS service</li>
            <li><em>Exceptions</em> - When errors occur during program execution (e.g., division by zero)</li>
          </ul>
        </li>
      </ol>
      <p>
        Interrupts can also be categorized by priority, with some being <em>maskable</em> (can be temporarily disabled)
        and others being <em>non-maskable</em> (always processed regardless of CPU state).
      </p>
      <p>
        When an interrupt occurs, the CPU completes its current instruction, saves the current state,
        and transfers control to the appropriate Interrupt Service Routine (ISR).
      </p>
    `,
    
    ivt: `
      <h3>Interrupt Vector Table (IVT)</h3>
      <p>
        The Interrupt Vector Table (IVT) is a data structure that maps interrupt types to the memory addresses
        of their corresponding Interrupt Service Routines (ISRs). It serves as a lookup table that the CPU
        consults to find the correct handler when an interrupt occurs.
      </p>
      <p>
        In most architectures, the IVT is stored at a fixed location in memory. For example:
      </p>
      <ul>
        <li>In x86 real mode, the IVT is located at physical addresses 0x0000 to 0x03FF</li>
        <li>Each entry is typically 4 bytes (2 bytes for segment and 2 bytes for offset in real mode)</li>
        <li>Modern operating systems use more sophisticated mechanisms like the Interrupt Descriptor Table (IDT) in protected mode</li>
      </ul>
      <p>
        When the processor receives an interrupt signal, it:
      </p>
      <ol>
        <li>Identifies the interrupt type/number</li>
        <li>Uses this number as an index into the IVT</li>
        <li>Retrieves the address of the corresponding ISR</li>
        <li>Jumps to that address to execute the interrupt handler</li>
      </ol>
      <p>
        The IVT organization allows the operating system to efficiently manage different types of interrupts
        without hardcoding handler addresses throughout the system.
      </p>
    `,
    
    isr: `
      <h3>Interrupt Service Routines (ISRs)</h3>
      <p>
        Interrupt Service Routines (ISRs) are specialized functions that handle specific types of interrupts.
        When an interrupt occurs, the CPU executes the corresponding ISR to address the event that triggered the interrupt.
      </p>
      <p>
        Key characteristics of ISRs include:
      </p>
      <ul>
        <li><strong>Short and Efficient</strong> - ISRs should execute quickly to minimize system disruption</li>
        <li><strong>Minimal Context</strong> - They typically operate with minimal system resources</li>
        <li><strong>Non-Reentrant</strong> - Most ISRs cannot be interrupted by the same type of interrupt</li>
        <li><strong>Critical Sections</strong> - Often contain code that must execute atomically</li>
      </ul>
      <p>
        A typical ISR performs these steps:
      </p>
      <ol>
        <li>Save additional context if needed (beyond what the CPU automatically saves)</li>
        <li>Process the interrupt (e.g., read input data, clear interrupt flags)</li>
        <li>Perform the necessary operations</li>
        <li>Signal completion to hardware if required</li>
        <li>Restore the saved context</li>
        <li>Return control to the interrupted process</li>
      </ol>
      <p>
        In modern operating systems, ISRs are often split into top and bottom halves:
        The top half runs immediately with interrupts disabled, handling critical tasks,
        while the bottom half runs later with interrupts enabled, handling less time-critical tasks.
      </p>
    `,
    
    pcb: `
      <h3>Process Control Block (PCB)</h3>
      <p>
        The Process Control Block (PCB) is a data structure that contains all the information about a specific process.
        When an interrupt occurs, the current state of the executing process must be saved to allow it to be resumed
        later after the interrupt handling is complete.
      </p>
      <p>
        The PCB typically stores:
      </p>
      <ul>
        <li><strong>Process ID</strong> - Unique identifier for the process</li>
        <li><strong>Process State</strong> - Running, ready, blocked, etc.</li>
        <li><strong>Program Counter (PC)</strong> - Address of the next instruction to execute</li>
        <li><strong>CPU Registers</strong> - Contents of processor registers</li>
        <li><strong>CPU Scheduling Information</strong> - Priority, scheduling queue, etc.</li>
        <li><strong>Memory Management Information</strong> - Base/limit registers, page tables, etc.</li>
        <li><strong>I/O Status Information</strong> - List of allocated I/O devices, open files, etc.</li>
        <li><strong>Accounting Information</strong> - CPU usage, time limits, etc.</li>
      </ul>
      <p>
        When a process is interrupted:
      </p>
      <ol>
        <li>The CPU automatically saves some context (e.g., PC, flags)</li>
        <li>The OS saves the remaining context to the PCB</li>
        <li>After the ISR executes, the OS restores the context from the PCB</li>
        <li>The process resumes execution from where it was interrupted</li>
      </ol>
      <p>
        This context switching mechanism is essential for multitasking operating systems,
        allowing them to handle interrupts while preserving the state of running processes.
      </p>
    `
  };
  
  // Function to initialize the theory section
  export function initTheory() {
    const theoryContent = document.getElementById('theory-content');
    const theoryTabs = document.querySelectorAll('.theory-tab');
    
    // Set the initial content (Introduction)
    displayTheoryContent('intro');
    
    // Add event listeners to all tabs
    theoryTabs.forEach(tab => {
      tab.addEventListener('click', () => {
        // Remove active class from all tabs
        theoryTabs.forEach(t => t.classList.remove('active'));
        
        // Add active class to the clicked tab
        tab.classList.add('active');
        
        // Display the corresponding content
        const tabId = tab.getAttribute('data-tab');
        displayTheoryContent(tabId);
      });
    });
  }
  
  // Function to display the content for a specific theory tab
  function displayTheoryContent(tabId) {
    const contentElement = document.getElementById('theory-content');
    contentElement.innerHTML = theoryContent[tabId] || 'Content not found';
    
    // Add fade-in effect
    contentElement.classList.add('fade-in');
    setTimeout(() => {
      contentElement.classList.remove('fade-in');
    }, 300);
  }